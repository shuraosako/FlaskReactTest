{"ast":null,"code":"/**\n    * @license\n    * Copyright 2021 Google LLC. All Rights Reserved.\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    * http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    * =============================================================================\n    */\nimport * as tf from \"@tensorflow/tfjs-core\";\nimport { tidy, sub, div, util, Tensor, browser, image, pad3d, cast, expandDims, squeeze, sigmoid, scalar, mul, reshape, argMax, concat, tensor2d, add } from \"@tensorflow/tfjs-core\";\nimport { loadGraphModel } from \"@tensorflow/tfjs-converter\";\nvar extendStatics = function (e, t) {\n  return (extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  })(e, t);\n};\nfunction __extends(e, t) {\n  function n() {\n    this.constructor = e;\n  }\n  extendStatics(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n}\nvar __assign = function () {\n  return (__assign = Object.assign || function (e) {\n    for (var t, n = 1, r = arguments.length; n < r; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n    return e;\n  }).apply(this, arguments);\n};\nfunction __awaiter(e, t, n, r) {\n  return new (n || (n = Promise))(function (o, i) {\n    function s(e) {\n      try {\n        a(r.next(e));\n      } catch (e) {\n        i(e);\n      }\n    }\n    function u(e) {\n      try {\n        a(r.throw(e));\n      } catch (e) {\n        i(e);\n      }\n    }\n    function a(e) {\n      e.done ? o(e.value) : new n(function (t) {\n        t(e.value);\n      }).then(s, u);\n    }\n    a((r = r.apply(e, t || [])).next());\n  });\n}\nfunction __generator(e, t) {\n  var n,\n    r,\n    o,\n    i,\n    s = {\n      label: 0,\n      sent: function () {\n        if (1 & o[0]) throw o[1];\n        return o[1];\n      },\n      trys: [],\n      ops: []\n    };\n  return i = {\n    next: u(0),\n    throw: u(1),\n    return: u(2)\n  }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n    return this;\n  }), i;\n  function u(i) {\n    return function (u) {\n      return function (i) {\n        if (n) throw new TypeError(\"Generator is already executing.\");\n        for (; s;) try {\n          if (n = 1, r && (o = 2 & i[0] ? r.return : i[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, i[1])).done) return o;\n          switch (r = 0, o && (i = [2 & i[0], o.value]), i[0]) {\n            case 0:\n            case 1:\n              o = i;\n              break;\n            case 4:\n              return s.label++, {\n                value: i[1],\n                done: !1\n              };\n            case 5:\n              s.label++, r = i[1], i = [0];\n              continue;\n            case 7:\n              i = s.ops.pop(), s.trys.pop();\n              continue;\n            default:\n              if (!(o = (o = s.trys).length > 0 && o[o.length - 1]) && (6 === i[0] || 2 === i[0])) {\n                s = 0;\n                continue;\n              }\n              if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {\n                s.label = i[1];\n                break;\n              }\n              if (6 === i[0] && s.label < o[1]) {\n                s.label = o[1], o = i;\n                break;\n              }\n              if (o && s.label < o[2]) {\n                s.label = o[2], s.ops.push(i);\n                break;\n              }\n              o[2] && s.ops.pop(), s.trys.pop();\n              continue;\n          }\n          i = t.call(e, s);\n        } catch (e) {\n          i = [6, e], r = 0;\n        } finally {\n          n = o = 0;\n        }\n        if (5 & i[0]) throw i[1];\n        return {\n          value: i[0] ? i[1] : void 0,\n          done: !0\n        };\n      }([i, u]);\n    };\n  }\n}\nvar BaseModel = function () {\n    function e(e, t) {\n      this.model = e, this.outputStride = t;\n      var n = this.model.inputs[0].shape;\n      util.assert(-1 === n[1] && -1 === n[2], function () {\n        return \"Input shape [\" + n[1] + \", \" + n[2] + \"] must both be equal to or -1\";\n      });\n    }\n    return e.prototype.predict = function (e) {\n      var t = this;\n      return tidy(function () {\n        var n = t.preprocessInput(cast(e, \"float32\")),\n          r = expandDims(n, 0),\n          o = t.model.predict(r).map(function (e) {\n            return squeeze(e, [0]);\n          }),\n          i = t.nameOutputResults(o);\n        return {\n          heatmapScores: sigmoid(i.heatmap),\n          offsets: i.offsets,\n          displacementFwd: i.displacementFwd,\n          displacementBwd: i.displacementBwd\n        };\n      });\n    }, e.prototype.dispose = function () {\n      this.model.dispose();\n    }, e;\n  }(),\n  MobileNet = function (e) {\n    function t() {\n      return null !== e && e.apply(this, arguments) || this;\n    }\n    return __extends(t, e), t.prototype.preprocessInput = function (e) {\n      return tidy(function () {\n        return sub(div(e, 127.5), 1);\n      });\n    }, t.prototype.nameOutputResults = function (e) {\n      return {\n        offsets: e[0],\n        heatmap: e[1],\n        displacementFwd: e[2],\n        displacementBwd: e[3]\n      };\n    }, t;\n  }(BaseModel);\nfunction half(e) {\n  return Math.floor(e / 2);\n}\nvar MaxHeap = function () {\n  function e(e, t) {\n    this.priorityQueue = new Array(e), this.numberOfElements = -1, this.getElementValue = t;\n  }\n  return e.prototype.enqueue = function (e) {\n    this.priorityQueue[++this.numberOfElements] = e, this.swim(this.numberOfElements);\n  }, e.prototype.dequeue = function () {\n    var e = this.priorityQueue[0];\n    return this.exchange(0, this.numberOfElements--), this.sink(0), this.priorityQueue[this.numberOfElements + 1] = null, e;\n  }, e.prototype.empty = function () {\n    return -1 === this.numberOfElements;\n  }, e.prototype.size = function () {\n    return this.numberOfElements + 1;\n  }, e.prototype.all = function () {\n    return this.priorityQueue.slice(0, this.numberOfElements + 1);\n  }, e.prototype.max = function () {\n    return this.priorityQueue[0];\n  }, e.prototype.swim = function (e) {\n    for (; e > 0 && this.less(half(e), e);) this.exchange(e, half(e)), e = half(e);\n  }, e.prototype.sink = function (e) {\n    for (; 2 * e <= this.numberOfElements;) {\n      var t = 2 * e;\n      if (t < this.numberOfElements && this.less(t, t + 1) && t++, !this.less(e, t)) break;\n      this.exchange(e, t), e = t;\n    }\n  }, e.prototype.getValueAt = function (e) {\n    return this.getElementValue(this.priorityQueue[e]);\n  }, e.prototype.less = function (e, t) {\n    return this.getValueAt(e) < this.getValueAt(t);\n  }, e.prototype.exchange = function (e, t) {\n    var n = this.priorityQueue[e];\n    this.priorityQueue[e] = this.priorityQueue[t], this.priorityQueue[t] = n;\n  }, e;\n}();\nfunction scoreIsMaximumInLocalWindow(e, t, n, r, o, i) {\n  for (var s = i.shape, u = s[0], a = s[1], l = !0, p = Math.max(n - o, 0), c = Math.min(n + o + 1, u), d = p; d < c; ++d) {\n    for (var f = Math.max(r - o, 0), h = Math.min(r + o + 1, a), m = f; m < h; ++m) if (i.get(d, m, e) > t) {\n      l = !1;\n      break;\n    }\n    if (!l) break;\n  }\n  return l;\n}\nfunction buildPartWithScoreQueue(e, t, n) {\n  for (var r = n.shape, o = r[0], i = r[1], s = r[2], u = new MaxHeap(o * i * s, function (e) {\n      return e.score;\n    }), a = 0; a < o; ++a) for (var l = 0; l < i; ++l) for (var p = 0; p < s; ++p) {\n    var c = n.get(a, l, p);\n    c < e || scoreIsMaximumInLocalWindow(p, c, a, l, t, n) && u.enqueue({\n      score: c,\n      part: {\n        heatmapY: a,\n        heatmapX: l,\n        id: p\n      }\n    });\n  }\n  return u;\n}\nvar partNames = [\"nose\", \"leftEye\", \"rightEye\", \"leftEar\", \"rightEar\", \"leftShoulder\", \"rightShoulder\", \"leftElbow\", \"rightElbow\", \"leftWrist\", \"rightWrist\", \"leftHip\", \"rightHip\", \"leftKnee\", \"rightKnee\", \"leftAnkle\", \"rightAnkle\"],\n  NUM_KEYPOINTS = partNames.length,\n  partIds = partNames.reduce(function (e, t, n) {\n    return e[t] = n, e;\n  }, {}),\n  connectedPartNames = [[\"leftHip\", \"leftShoulder\"], [\"leftElbow\", \"leftShoulder\"], [\"leftElbow\", \"leftWrist\"], [\"leftHip\", \"leftKnee\"], [\"leftKnee\", \"leftAnkle\"], [\"rightHip\", \"rightShoulder\"], [\"rightElbow\", \"rightShoulder\"], [\"rightElbow\", \"rightWrist\"], [\"rightHip\", \"rightKnee\"], [\"rightKnee\", \"rightAnkle\"], [\"leftShoulder\", \"rightShoulder\"], [\"leftHip\", \"rightHip\"]],\n  poseChain = [[\"nose\", \"leftEye\"], [\"leftEye\", \"leftEar\"], [\"nose\", \"rightEye\"], [\"rightEye\", \"rightEar\"], [\"nose\", \"leftShoulder\"], [\"leftShoulder\", \"leftElbow\"], [\"leftElbow\", \"leftWrist\"], [\"leftShoulder\", \"leftHip\"], [\"leftHip\", \"leftKnee\"], [\"leftKnee\", \"leftAnkle\"], [\"nose\", \"rightShoulder\"], [\"rightShoulder\", \"rightElbow\"], [\"rightElbow\", \"rightWrist\"], [\"rightShoulder\", \"rightHip\"], [\"rightHip\", \"rightKnee\"], [\"rightKnee\", \"rightAnkle\"]],\n  connectedPartIndices = connectedPartNames.map(function (e) {\n    var t = e[0],\n      n = e[1];\n    return [partIds[t], partIds[n]];\n  }),\n  partChannels = [\"left_face\", \"right_face\", \"right_upper_leg_front\", \"right_lower_leg_back\", \"right_upper_leg_back\", \"left_lower_leg_front\", \"left_upper_leg_front\", \"left_upper_leg_back\", \"left_lower_leg_back\", \"right_feet\", \"right_lower_leg_front\", \"left_feet\", \"torso_front\", \"torso_back\", \"right_upper_arm_front\", \"right_upper_arm_back\", \"right_lower_arm_back\", \"left_lower_arm_front\", \"left_upper_arm_front\", \"left_upper_arm_back\", \"left_lower_arm_back\", \"right_hand\", \"right_lower_arm_front\", \"left_hand\"];\nfunction getOffsetPoint(e, t, n, r) {\n  return {\n    y: r.get(e, t, n),\n    x: r.get(e, t, n + NUM_KEYPOINTS)\n  };\n}\nfunction getImageCoords(e, t, n) {\n  var r = getOffsetPoint(e.heatmapY, e.heatmapX, e.id, n),\n    o = r.y,\n    i = r.x;\n  return {\n    x: e.heatmapX * t + i,\n    y: e.heatmapY * t + o\n  };\n}\nfunction clamp(e, t, n) {\n  return e < t ? t : e > n ? n : e;\n}\nfunction squaredDistance(e, t, n, r) {\n  var o = n - e,\n    i = r - t;\n  return o * o + i * i;\n}\nfunction addVectors(e, t) {\n  return {\n    x: e.x + t.x,\n    y: e.y + t.y\n  };\n}\nvar parentChildrenTuples = poseChain.map(function (e) {\n    var t = e[0],\n      n = e[1];\n    return [partIds[t], partIds[n]];\n  }),\n  parentToChildEdges = parentChildrenTuples.map(function (e) {\n    return e[1];\n  }),\n  childToParentEdges = parentChildrenTuples.map(function (e) {\n    return e[0];\n  });\nfunction getDisplacement(e, t, n) {\n  var r = n.shape[2] / 2;\n  return {\n    y: n.get(t.y, t.x, e),\n    x: n.get(t.y, t.x, r + e)\n  };\n}\nfunction getStridedIndexNearPoint(e, t, n, r) {\n  return {\n    y: clamp(Math.round(e.y / t), 0, n - 1),\n    x: clamp(Math.round(e.x / t), 0, r - 1)\n  };\n}\nfunction traverseToTargetKeypoint(e, t, n, r, o, i, s, u) {\n  void 0 === u && (u = 2);\n  for (var a = r.shape, l = a[0], p = a[1], c = getDisplacement(e, getStridedIndexNearPoint(t.position, i, l, p), s), d = addVectors(t.position, c), f = 0; f < u; f++) {\n    var h = getStridedIndexNearPoint(d, i, l, p),\n      m = getOffsetPoint(h.y, h.x, n, o);\n    d = addVectors({\n      x: h.x * i,\n      y: h.y * i\n    }, {\n      x: m.x,\n      y: m.y\n    });\n  }\n  var g = getStridedIndexNearPoint(d, i, l, p),\n    _ = r.get(g.y, g.x, n);\n  return {\n    position: d,\n    part: partNames[n],\n    score: _\n  };\n}\nfunction decodePose(e, t, n, r, o, i) {\n  var s = t.shape[2],\n    u = parentToChildEdges.length,\n    a = new Array(s),\n    l = e.part,\n    p = e.score,\n    c = getImageCoords(l, r, n);\n  a[l.id] = {\n    score: p,\n    part: partNames[l.id],\n    position: c\n  };\n  for (var d = u - 1; d >= 0; --d) {\n    var f = parentToChildEdges[d],\n      h = childToParentEdges[d];\n    a[f] && !a[h] && (a[h] = traverseToTargetKeypoint(d, a[f], h, t, n, r, i));\n  }\n  for (d = 0; d < u; ++d) {\n    f = childToParentEdges[d], h = parentToChildEdges[d];\n    a[f] && !a[h] && (a[h] = traverseToTargetKeypoint(d, a[f], h, t, n, r, o));\n  }\n  return a;\n}\nfunction withinNmsRadiusOfCorrespondingPoint(e, t, n, r) {\n  var o = n.x,\n    i = n.y;\n  return e.some(function (e) {\n    var n = e.keypoints[r].position;\n    return squaredDistance(i, o, n.y, n.x) <= t;\n  });\n}\nfunction getInstanceScore(e, t, n) {\n  return n.reduce(function (n, r, o) {\n    var i = r.position,\n      s = r.score;\n    return withinNmsRadiusOfCorrespondingPoint(e, t, i, o) || (n += s), n;\n  }, 0) / n.length;\n}\nvar kLocalMaximumRadius = 1;\nfunction decodeMultiplePoses(e, t, n, r, o, i, s, u) {\n  void 0 === s && (s = .5), void 0 === u && (u = 20);\n  for (var a = [], l = buildPartWithScoreQueue(s, kLocalMaximumRadius, e), p = u * u; a.length < i && !l.empty();) {\n    var c = l.dequeue();\n    if (!withinNmsRadiusOfCorrespondingPoint(a, p, getImageCoords(c.part, o, t), c.part.id)) {\n      var d = decodePose(c, e, t, o, n, r),\n        f = getInstanceScore(a, p, d);\n      a.push({\n        keypoints: d,\n        score: f\n      });\n    }\n  }\n  return a;\n}\nfunction mod(e, t) {\n  return tidy(function () {\n    var n = div(e, scalar(t, \"int32\"));\n    return sub(e, mul(n, scalar(t, \"int32\")));\n  });\n}\nfunction argmax2d(e) {\n  var t = e.shape,\n    n = t[0],\n    r = t[1],\n    o = t[2];\n  return tidy(function () {\n    var t = reshape(e, [n * r, o]),\n      i = argMax(t, 0),\n      s = expandDims(div(i, scalar(r, \"int32\")), 1),\n      u = expandDims(mod(i, r), 1);\n    return concat([s, u], 1);\n  });\n}\nfunction getPointsConfidence(e, t) {\n  for (var n = t.shape[0], r = new Float32Array(n), o = 0; o < n; o++) {\n    var i = t.get(o, 0),\n      s = t.get(o, 1);\n    r[o] = e.get(i, s, o);\n  }\n  return r;\n}\nfunction getOffsetPoint$1(e, t, n, r) {\n  return {\n    y: r.get(e, t, n),\n    x: r.get(e, t, n + NUM_KEYPOINTS)\n  };\n}\nfunction getOffsetVectors(e, t) {\n  for (var n = [], r = 0; r < NUM_KEYPOINTS; r++) {\n    var o = getOffsetPoint$1(e.get(r, 0).valueOf(), e.get(r, 1).valueOf(), r, t),\n      i = o.x,\n      s = o.y;\n    n.push(s), n.push(i);\n  }\n  return tensor2d(n, [NUM_KEYPOINTS, 2]);\n}\nfunction getOffsetPoints(e, t, n) {\n  return tidy(function () {\n    var r = getOffsetVectors(e, n);\n    return add(cast(mul(e.toTensor(), scalar(t, \"int32\")), \"float32\"), r);\n  });\n}\nfunction decodeSinglePose(e, t, n) {\n  return __awaiter(this, void 0, void 0, function () {\n    var r, o, i, s, u, a, l, p, c, d;\n    return __generator(this, function (f) {\n      switch (f.label) {\n        case 0:\n          return r = 0, o = argmax2d(e), [4, Promise.all([e.buffer(), t.buffer(), o.buffer()])];\n        case 1:\n          return i = f.sent(), s = i[0], u = i[1], a = i[2], [4, (l = getOffsetPoints(a, n, u)).buffer()];\n        case 2:\n          return p = f.sent(), c = Array.from(getPointsConfidence(s, a)), d = c.map(function (e, t) {\n            return r += e, {\n              position: {\n                y: p.get(t, 0),\n                x: p.get(t, 1)\n              },\n              part: partNames[t],\n              score: e\n            };\n          }), o.dispose(), l.dispose(), [2, {\n            keypoints: d,\n            score: r / d.length\n          }];\n      }\n    });\n  });\n}\nvar MOBILENET_BASE_URL = \"https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/\",\n  RESNET50_BASE_URL = \"https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/\";\nfunction resNet50Checkpoint(e, t) {\n  var n = \"model-stride\" + e + \".json\";\n  return 4 === t ? RESNET50_BASE_URL + \"float/\" + n : RESNET50_BASE_URL + \"quant\" + t + \"/\" + n;\n}\nfunction mobileNetCheckpoint(e, t, n) {\n  var r = {\n      1: \"100\",\n      .75: \"075\",\n      .5: \"050\"\n    },\n    o = \"model-stride\" + e + \".json\";\n  return 4 === n ? MOBILENET_BASE_URL + \"float/\" + r[t] + \"/\" + o : MOBILENET_BASE_URL + \"quant\" + n + \"/\" + r[t] + \"/\" + o;\n}\nvar imageNetMean = [-123.15, -115.9, -103.06],\n  ResNet = function (e) {\n    function t() {\n      return null !== e && e.apply(this, arguments) || this;\n    }\n    return __extends(t, e), t.prototype.preprocessInput = function (e) {\n      return add(e, imageNetMean);\n    }, t.prototype.nameOutputResults = function (e) {\n      var t = e[0],\n        n = e[1];\n      return {\n        offsets: e[2],\n        heatmap: e[3],\n        displacementFwd: t,\n        displacementBwd: n\n      };\n    }, t;\n  }(BaseModel);\nfunction eitherPointDoesntMeetConfidence(e, t, n) {\n  return e < n || t < n;\n}\nfunction getAdjacentKeyPoints(e, t) {\n  return connectedPartIndices.reduce(function (n, r) {\n    var o = r[0],\n      i = r[1];\n    return eitherPointDoesntMeetConfidence(e[o].score, e[i].score, t) ? n : (n.push([e[o], e[i]]), n);\n  }, []);\n}\nvar NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,\n  POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\nfunction getBoundingBox(e) {\n  return e.reduce(function (e, t) {\n    var n = e.maxX,\n      r = e.maxY,\n      o = e.minX,\n      i = e.minY,\n      s = t.position,\n      u = s.x,\n      a = s.y;\n    return {\n      maxX: Math.max(n, u),\n      maxY: Math.max(r, a),\n      minX: Math.min(o, u),\n      minY: Math.min(i, a)\n    };\n  }, {\n    maxX: NEGATIVE_INFINITY,\n    maxY: NEGATIVE_INFINITY,\n    minX: POSITIVE_INFINITY,\n    minY: POSITIVE_INFINITY\n  });\n}\nfunction getBoundingBoxPoints(e) {\n  var t = getBoundingBox(e),\n    n = t.minX,\n    r = t.minY,\n    o = t.maxX,\n    i = t.maxY;\n  return [{\n    x: n,\n    y: r\n  }, {\n    x: o,\n    y: r\n  }, {\n    x: o,\n    y: i\n  }, {\n    x: n,\n    y: i\n  }];\n}\nfunction toTensorBuffers3D(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (t) {\n      return [2, Promise.all(e.map(function (e) {\n        return e.buffer();\n      }))];\n    });\n  });\n}\nfunction scalePose(e, t, n, r, o) {\n  return void 0 === r && (r = 0), void 0 === o && (o = 0), {\n    score: e.score,\n    keypoints: e.keypoints.map(function (e) {\n      var i = e.score,\n        s = e.part,\n        u = e.position;\n      return {\n        score: i,\n        part: s,\n        position: {\n          x: u.x * n + o,\n          y: u.y * t + r\n        }\n      };\n    })\n  };\n}\nfunction scalePoses(e, t, n, r, o) {\n  return void 0 === r && (r = 0), void 0 === o && (o = 0), 1 === n && 1 === t && 0 === r && 0 === o ? e : e.map(function (e) {\n    return scalePose(e, t, n, r, o);\n  });\n}\nfunction flipPoseHorizontal(e, t) {\n  return {\n    score: e.score,\n    keypoints: e.keypoints.map(function (e) {\n      var n = e.score,\n        r = e.part,\n        o = e.position;\n      return {\n        score: n,\n        part: r,\n        position: {\n          x: t - 1 - o.x,\n          y: o.y\n        }\n      };\n    })\n  };\n}\nfunction flipPosesHorizontal(e, t) {\n  return t <= 0 ? e : e.map(function (e) {\n    return flipPoseHorizontal(e, t);\n  });\n}\nfunction toValidInputResolution(e, t) {\n  return isValidInputResolution(e, t) ? e : Math.floor(e / t) * t + 1;\n}\nfunction validateInputResolution(e) {\n  util.assert(\"number\" == typeof e || \"object\" == typeof e, function () {\n    return \"Invalid inputResolution \" + e + \". Should be a number or an object with width and height\";\n  }), \"object\" == typeof e && (util.assert(\"number\" == typeof e.width, function () {\n    return \"inputResolution.width has a value of \" + e.width + \" which is invalid; it must be a number\";\n  }), util.assert(\"number\" == typeof e.height, function () {\n    return \"inputResolution.height has a value of \" + e.height + \" which is invalid; it must be a number\";\n  }));\n}\nfunction getValidInputResolutionDimensions(e, t) {\n  return validateInputResolution(e), \"object\" == typeof e ? [toValidInputResolution(e.height, t), toValidInputResolution(e.width, t)] : [toValidInputResolution(e, t), toValidInputResolution(e, t)];\n}\nvar VALID_OUTPUT_STRIDES = [8, 16, 32];\nfunction assertValidOutputStride(e) {\n  util.assert(\"number\" == typeof e, function () {\n    return \"outputStride is not a number\";\n  }), util.assert(VALID_OUTPUT_STRIDES.indexOf(e) >= 0, function () {\n    return \"outputStride of \" + e + \" is invalid. It must be either 8, 16, or 32\";\n  });\n}\nfunction isValidInputResolution(e, t) {\n  return (e - 1) % t == 0;\n}\nfunction assertValidResolution(e, t) {\n  util.assert(\"number\" == typeof e[0] && \"number\" == typeof e[1], function () {\n    return \"both resolution values must be a number but had values \" + e;\n  }), util.assert(isValidInputResolution(e[0], t), function () {\n    return \"height of \" + e[0] + \" is invalid for output stride \" + t + \".\";\n  }), util.assert(isValidInputResolution(e[1], t), function () {\n    return \"width of \" + e[1] + \" is invalid for output stride \" + t + \".\";\n  });\n}\nfunction getInputTensorDimensions(e) {\n  return e instanceof Tensor ? [e.shape[0], e.shape[1]] : [e.height, e.width];\n}\nfunction toInputTensor(e) {\n  return e instanceof Tensor ? e : browser.fromPixels(e);\n}\nfunction padAndResizeTo(e, t) {\n  var n = t[0],\n    r = t[1],\n    o = getInputTensorDimensions(e),\n    i = o[0],\n    s = o[1],\n    u = r / n,\n    a = [0, 0, 0, 0],\n    l = a[0],\n    p = a[1],\n    c = a[2],\n    d = a[3];\n  return s / i < u ? (l = 0, p = 0, c = Math.round(.5 * (u * i - s)), d = Math.round(.5 * (u * i - s))) : (l = Math.round(.5 * (1 / u * s - i)), p = Math.round(.5 * (1 / u * s - i)), c = 0, d = 0), {\n    resized: tidy(function () {\n      var t = toInputTensor(e);\n      return t = pad3d(t, [[l, p], [c, d], [0, 0]]), image.resizeBilinear(t, [n, r]);\n    }),\n    padding: {\n      top: l,\n      left: c,\n      right: d,\n      bottom: p\n    }\n  };\n}\nfunction scaleAndFlipPoses(e, t, n, r, o) {\n  var i = t[0],\n    s = t[1],\n    u = n[0],\n    a = n[1],\n    l = scalePoses(e, (i + r.top + r.bottom) / u, (s + r.left + r.right) / a, -r.top, -r.left);\n  return o ? flipPosesHorizontal(l, s) : l;\n}\nvar MOBILENET_V1_CONFIG = {\n    architecture: \"MobileNetV1\",\n    outputStride: 16,\n    multiplier: .75,\n    inputResolution: 257\n  },\n  VALID_ARCHITECTURE = [\"MobileNetV1\", \"ResNet50\"],\n  VALID_STRIDE = {\n    MobileNetV1: [8, 16, 32],\n    ResNet50: [32, 16]\n  },\n  VALID_MULTIPLIER = {\n    MobileNetV1: [.5, .75, 1],\n    ResNet50: [1]\n  },\n  VALID_QUANT_BYTES = [1, 2, 4];\nfunction validateModelConfig(e) {\n  if (null == (e = e || MOBILENET_V1_CONFIG).architecture && (e.architecture = \"MobileNetV1\"), VALID_ARCHITECTURE.indexOf(e.architecture) < 0) throw new Error(\"Invalid architecture \" + e.architecture + \". Should be one of \" + VALID_ARCHITECTURE);\n  if (null == e.inputResolution && (e.inputResolution = 257), validateInputResolution(e.inputResolution), null == e.outputStride && (e.outputStride = 16), VALID_STRIDE[e.architecture].indexOf(e.outputStride) < 0) throw new Error(\"Invalid outputStride \" + e.outputStride + \". Should be one of \" + VALID_STRIDE[e.architecture] + \" for architecture \" + e.architecture + \".\");\n  if (null == e.multiplier && (e.multiplier = 1), VALID_MULTIPLIER[e.architecture].indexOf(e.multiplier) < 0) throw new Error(\"Invalid multiplier \" + e.multiplier + \". Should be one of \" + VALID_MULTIPLIER[e.architecture] + \" for architecture \" + e.architecture + \".\");\n  if (null == e.quantBytes && (e.quantBytes = 4), VALID_QUANT_BYTES.indexOf(e.quantBytes) < 0) throw new Error(\"Invalid quantBytes \" + e.quantBytes + \". Should be one of \" + VALID_QUANT_BYTES + \" for architecture \" + e.architecture + \".\");\n  if (\"MobileNetV1\" === e.architecture && 32 === e.outputStride && 1 !== e.multiplier) throw new Error(\"When using an output stride of 32, you must select 1 as the multiplier.\");\n  return e;\n}\nvar SINGLE_PERSON_INFERENCE_CONFIG = {\n    flipHorizontal: !1\n  },\n  MULTI_PERSON_INFERENCE_CONFIG = {\n    flipHorizontal: !1,\n    maxDetections: 5,\n    scoreThreshold: .5,\n    nmsRadius: 20\n  };\nfunction validateMultiPersonInputConfig(e) {\n  var t = e.maxDetections,\n    n = e.scoreThreshold,\n    r = e.nmsRadius;\n  if (t <= 0) throw new Error(\"Invalid maxDetections \" + t + \". Should be > 0\");\n  if (n < 0 || n > 1) throw new Error(\"Invalid scoreThreshold \" + n + \". Should be in range [0.0, 1.0]\");\n  if (r <= 0) throw new Error(\"Invalid nmsRadius \" + r + \".\");\n}\nvar PoseNet = function () {\n  function e(e, t) {\n    assertValidOutputStride(e.outputStride), assertValidResolution(t, e.outputStride), this.baseModel = e, this.inputResolution = t;\n  }\n  return e.prototype.estimateMultiplePoses = function (e, t) {\n    return void 0 === t && (t = MULTI_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {\n      var n, r, o, i, s, u, a, l, p, c, d, f, h, m, g, _, I, v, y, E, b;\n      return __generator(this, function (N) {\n        switch (N.label) {\n          case 0:\n            return n = __assign({}, MULTI_PERSON_INFERENCE_CONFIG, t), validateMultiPersonInputConfig(t), r = this.baseModel.outputStride, o = this.inputResolution, i = getInputTensorDimensions(e), s = i[0], u = i[1], a = padAndResizeTo(e, o), l = a.resized, p = a.padding, c = this.baseModel.predict(l), d = c.heatmapScores, f = c.offsets, h = c.displacementFwd, m = c.displacementBwd, [4, toTensorBuffers3D([d, f, h, m])];\n          case 1:\n            return g = N.sent(), _ = g[0], I = g[1], v = g[2], y = g[3], [4, decodeMultiplePoses(_, I, v, y, r, n.maxDetections, n.scoreThreshold, n.nmsRadius)];\n          case 2:\n            return E = N.sent(), b = scaleAndFlipPoses(E, [s, u], o, p, n.flipHorizontal), d.dispose(), f.dispose(), h.dispose(), m.dispose(), l.dispose(), [2, b];\n        }\n      });\n    });\n  }, e.prototype.estimateSinglePose = function (e, t) {\n    return void 0 === t && (t = SINGLE_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {\n      var n, r, o, i, s, u, a, l, p, c, d, f, h, m, g, _;\n      return __generator(this, function (I) {\n        switch (I.label) {\n          case 0:\n            return n = __assign({}, SINGLE_PERSON_INFERENCE_CONFIG, t), r = this.baseModel.outputStride, o = this.inputResolution, i = getInputTensorDimensions(e), s = i[0], u = i[1], a = padAndResizeTo(e, o), l = a.resized, p = a.padding, c = this.baseModel.predict(l), d = c.heatmapScores, f = c.offsets, h = c.displacementFwd, m = c.displacementBwd, [4, decodeSinglePose(d, f, r)];\n          case 1:\n            return g = I.sent(), _ = scaleAndFlipPoses([g], [s, u], o, p, n.flipHorizontal), d.dispose(), f.dispose(), h.dispose(), m.dispose(), l.dispose(), [2, _[0]];\n        }\n      });\n    });\n  }, e.prototype.estimatePoses = function (e, t) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (n) {\n        switch (n.label) {\n          case 0:\n            return \"single-person\" !== t.decodingMethod ? [3, 2] : [4, this.estimateSinglePose(e, t)];\n          case 1:\n            return [2, [n.sent()]];\n          case 2:\n            return [2, this.estimateMultiplePoses(e, t)];\n        }\n      });\n    });\n  }, e.prototype.dispose = function () {\n    this.baseModel.dispose();\n  }, e;\n}();\nfunction loadMobileNet(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t, n, r, o, i, s, u;\n    return __generator(this, function (a) {\n      switch (a.label) {\n        case 0:\n          if (t = e.outputStride, n = e.quantBytes, r = e.multiplier, null == tf) throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\\n        model.\");\n          return o = mobileNetCheckpoint(t, r, n), [4, loadGraphModel(e.modelUrl || o)];\n        case 1:\n          return i = a.sent(), s = new MobileNet(i, t), u = getValidInputResolutionDimensions(e.inputResolution, s.outputStride), [2, new PoseNet(s, u)];\n      }\n    });\n  });\n}\nfunction loadResNet(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t, n, r, o, i, s;\n    return __generator(this, function (u) {\n      switch (u.label) {\n        case 0:\n          if (t = e.outputStride, n = e.quantBytes, null == tf) throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\\n        model.\");\n          return r = resNet50Checkpoint(t, n), [4, loadGraphModel(e.modelUrl || r)];\n        case 1:\n          return o = u.sent(), i = new ResNet(o, t), s = getValidInputResolutionDimensions(e.inputResolution, i.outputStride), [2, new PoseNet(i, s)];\n      }\n    });\n  });\n}\nfunction load(e) {\n  return void 0 === e && (e = MOBILENET_V1_CONFIG), __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (t) {\n      return \"ResNet50\" === (e = validateModelConfig(e)).architecture ? [2, loadResNet(e)] : \"MobileNetV1\" === e.architecture ? [2, loadMobileNet(e)] : [2, null];\n    });\n  });\n}\nvar version = \"2.2.2\";\nexport { decodeMultiplePoses, decodeSinglePose, MobileNet, partChannels, partIds, partNames, poseChain, load, PoseNet, getAdjacentKeyPoints, getBoundingBox, getBoundingBoxPoints, scaleAndFlipPoses, scalePose, version };","map":{"version":3,"names":["BaseModel","e","t","model","outputStride","n","inputs","shape","util","assert","prototype","predict","tidy","preprocessInput","cast","r","expandDims","o","map","squeeze","i","nameOutputResults","heatmapScores","sigmoid","heatmap","offsets","displacementFwd","displacementBwd","dispose","MobileNet","apply","arguments","__extends","sub","div","half","Math","floor","MaxHeap","priorityQueue","Array","numberOfElements","getElementValue","enqueue","swim","dequeue","exchange","sink","empty","size","all","slice","max","less","getValueAt","scoreIsMaximumInLocalWindow","s","u","a","l","p","c","min","d","f","h","m","get","buildPartWithScoreQueue","score","part","heatmapY","heatmapX","id","partNames","NUM_KEYPOINTS","length","partIds","reduce","connectedPartNames","poseChain","connectedPartIndices","partChannels","getOffsetPoint","y","x","getImageCoords","clamp","squaredDistance","addVectors","parentChildrenTuples","parentToChildEdges","childToParentEdges","getDisplacement","getStridedIndexNearPoint","round","traverseToTargetKeypoint","position","g","_","decodePose","withinNmsRadiusOfCorrespondingPoint","some","keypoints","getInstanceScore","kLocalMaximumRadius","decodeMultiplePoses","push","mod","scalar","mul","argmax2d","reshape","argMax","concat","getPointsConfidence","Float32Array","getOffsetPoint$1","getOffsetVectors","valueOf","tensor2d","getOffsetPoints","add","toTensor","decodeSinglePose","__awaiter","__generator","label","Promise","buffer","sent","from","MOBILENET_BASE_URL","RESNET50_BASE_URL","resNet50Checkpoint","mobileNetCheckpoint","imageNetMean","ResNet","eitherPointDoesntMeetConfidence","getAdjacentKeyPoints","NEGATIVE_INFINITY","Number","POSITIVE_INFINITY","getBoundingBox","maxX","maxY","minX","minY","getBoundingBoxPoints","toTensorBuffers3D","scalePose","scalePoses","flipPoseHorizontal","flipPosesHorizontal","toValidInputResolution","isValidInputResolution","validateInputResolution","width","height","getValidInputResolutionDimensions","VALID_OUTPUT_STRIDES","assertValidOutputStride","indexOf","assertValidResolution","getInputTensorDimensions","Tensor","toInputTensor","browser","fromPixels","padAndResizeTo","resized","pad3d","image","resizeBilinear","padding","top","left","right","bottom","scaleAndFlipPoses","MOBILENET_V1_CONFIG","architecture","multiplier","inputResolution","VALID_ARCHITECTURE","VALID_STRIDE","MobileNetV1","ResNet50","VALID_MULTIPLIER","VALID_QUANT_BYTES","validateModelConfig","Error","quantBytes","SINGLE_PERSON_INFERENCE_CONFIG","flipHorizontal","MULTI_PERSON_INFERENCE_CONFIG","maxDetections","scoreThreshold","nmsRadius","validateMultiPersonInputConfig","PoseNet","baseModel","estimateMultiplePoses","I","v","E","b","N","__assign","estimateSinglePose","estimatePoses","decodingMethod","loadMobileNet","tf","loadGraphModel","modelUrl","loadResNet","load","version"],"sources":["C:\\Users\\81809\\Documents\\学校\\卒研\\kojitest1\\frontend\\node_modules\\@tensorflow-models\\posenet\\src\\base_model.ts","C:\\Users\\81809\\Documents\\学校\\卒研\\kojitest1\\frontend\\node_modules\\@tensorflow-models\\posenet\\src\\mobilenet.ts","C:\\Users\\81809\\Documents\\学校\\卒研\\kojitest1\\frontend\\node_modules\\@tensorflow-models\\posenet\\src\\multi_pose\\max_heap.ts","C:\\Users\\81809\\Documents\\学校\\卒研\\kojitest1\\frontend\\node_modules\\@tensorflow-models\\posenet\\src\\multi_pose\\build_part_with_score_queue.ts","C:\\Users\\81809\\Documents\\学校\\卒研\\kojitest1\\frontend\\node_modules\\@tensorflow-models\\posenet\\src\\keypoints.ts","C:\\Users\\81809\\Documents\\学校\\卒研\\kojitest1\\frontend\\node_modules\\@tensorflow-models\\posenet\\src\\multi_pose\\util.ts","C:\\Users\\81809\\Documents\\学校\\卒研\\kojitest1\\frontend\\node_modules\\@tensorflow-models\\posenet\\src\\multi_pose\\decode_pose.ts","C:\\Users\\81809\\Documents\\学校\\卒研\\kojitest1\\frontend\\node_modules\\@tensorflow-models\\posenet\\src\\multi_pose\\decode_multiple_poses.ts","C:\\Users\\81809\\Documents\\学校\\卒研\\kojitest1\\frontend\\node_modules\\@tensorflow-models\\posenet\\src\\single_pose\\argmax2d.ts","C:\\Users\\81809\\Documents\\学校\\卒研\\kojitest1\\frontend\\node_modules\\@tensorflow-models\\posenet\\src\\single_pose\\util.ts","C:\\Users\\81809\\Documents\\学校\\卒研\\kojitest1\\frontend\\node_modules\\@tensorflow-models\\posenet\\src\\single_pose\\decode_single_pose.ts","C:\\Users\\81809\\Documents\\学校\\卒研\\kojitest1\\frontend\\node_modules\\@tensorflow-models\\posenet\\src\\checkpoints.ts","C:\\Users\\81809\\Documents\\学校\\卒研\\kojitest1\\frontend\\node_modules\\@tensorflow-models\\posenet\\src\\resnet.ts","C:\\Users\\81809\\Documents\\学校\\卒研\\kojitest1\\frontend\\node_modules\\@tensorflow-models\\posenet\\src\\util.ts","C:\\Users\\81809\\Documents\\学校\\卒研\\kojitest1\\frontend\\node_modules\\@tensorflow-models\\posenet\\src\\posenet_model.ts","C:\\Users\\81809\\Documents\\学校\\卒研\\kojitest1\\frontend\\node_modules\\@tensorflow-models\\posenet\\src\\version.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tfconv from '@tensorflow/tfjs-converter';\nimport * as tf from '@tensorflow/tfjs-core';\nimport {PoseNetOutputStride} from './types';\n\n/**\n * PoseNet supports using various convolution neural network models\n * (e.g. ResNet and MobileNetV1) as its underlying base model.\n * The following BaseModel interface defines a unified interface for\n * creating such PoseNet base models. Currently both MobileNet (in\n * ./mobilenet.ts) and ResNet (in ./resnet.ts) implements the BaseModel\n * interface. New base models that conform to the BaseModel interface can be\n * added to PoseNet.\n */\nexport abstract class BaseModel {\n  constructor(\n      protected readonly model: tfconv.GraphModel,\n      public readonly outputStride: PoseNetOutputStride) {\n    const inputShape =\n        this.model.inputs[0].shape as [number, number, number, number];\n    tf.util.assert(\n        (inputShape[1] === -1) && (inputShape[2] === -1),\n        () => `Input shape [${inputShape[1]}, ${inputShape[2]}] ` +\n            `must both be equal to or -1`);\n  }\n\n  abstract preprocessInput(input: tf.Tensor3D): tf.Tensor3D;\n\n  /**\n   * Predicts intermediate Tensor representations.\n   *\n   * @param input The input RGB image of the base model.\n   * A Tensor of shape: [`inputResolution`, `inputResolution`, 3].\n   *\n   * @return A dictionary of base model's intermediate predictions.\n   * The returned dictionary should contains the following elements:\n   * heatmapScores: A Tensor3D that represents the heatmapScores.\n   * offsets: A Tensor3D that represents the offsets.\n   * displacementFwd: A Tensor3D that represents the forward displacement.\n   * displacementBwd: A Tensor3D that represents the backward displacement.\n   */\n  predict(input: tf.Tensor3D): {\n    heatmapScores: tf.Tensor3D,\n    offsets: tf.Tensor3D,\n    displacementFwd: tf.Tensor3D,\n    displacementBwd: tf.Tensor3D\n  } {\n    return tf.tidy(() => {\n      const asFloat = this.preprocessInput(tf.cast(input, 'float32'));\n      const asBatch = tf.expandDims(asFloat, 0);\n      const results = this.model.predict(asBatch) as tf.Tensor4D[];\n      const results3d: tf.Tensor3D[] = results.map(y => tf.squeeze(y, [0]));\n\n      const namedResults = this.nameOutputResults(results3d);\n\n      return {\n        heatmapScores: tf.sigmoid(namedResults.heatmap),\n        offsets: namedResults.offsets,\n        displacementFwd: namedResults.displacementFwd,\n        displacementBwd: namedResults.displacementBwd\n      };\n    });\n  }\n\n  // Because MobileNet and ResNet predict() methods output a different order for\n  // these values, we have a method that needs to be implemented to order them.\n  abstract nameOutputResults(results: tf.Tensor3D[]): {\n    heatmap: tf.Tensor3D,\n    offsets: tf.Tensor3D,\n    displacementFwd: tf.Tensor3D,\n    displacementBwd: tf.Tensor3D\n  };\n\n  /**\n   * Releases the CPU and GPU memory allocated by the model.\n   */\n  dispose() {\n    this.model.dispose();\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\nimport {BaseModel} from './base_model';\n\nexport class MobileNet extends BaseModel {\n  preprocessInput(input: tf.Tensor3D): tf.Tensor3D {\n    // Normalize the pixels [0, 255] to be between [-1, 1].\n    return tf.tidy(() => tf.sub(tf.div(input, 127.5), 1.0));\n  }\n\n  nameOutputResults(results: tf.Tensor3D[]) {\n    const [offsets, heatmap, displacementFwd, displacementBwd] = results;\n    return {offsets, heatmap, displacementFwd, displacementBwd};\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// algorithm based on Coursera Lecture from Algorithms, Part 1:\n// https://www.coursera.org/learn/algorithms-part1/lecture/ZjoSM/heapsort\n\nfunction half(k: number) {\n  return Math.floor(k / 2);\n}\n\nexport class MaxHeap<T> {\n  private priorityQueue: T[];\n  private numberOfElements: number;\n  private getElementValue: (element: T) => number;\n\n  constructor(maxSize: number, getElementValue: (element: T) => number) {\n    this.priorityQueue = new Array(maxSize);\n    this.numberOfElements = -1;\n    this.getElementValue = getElementValue;\n  }\n\n  public enqueue(x: T): void {\n    this.priorityQueue[++this.numberOfElements] = x;\n    this.swim(this.numberOfElements);\n  }\n\n  public dequeue(): T {\n    const max = this.priorityQueue[0];\n    this.exchange(0, this.numberOfElements--);\n    this.sink(0);\n    this.priorityQueue[this.numberOfElements + 1] = null;\n    return max;\n  }\n\n  public empty(): boolean {\n    return this.numberOfElements === -1;\n  }\n\n  public size(): number {\n    return this.numberOfElements + 1;\n  }\n\n  public all(): T[] {\n    return this.priorityQueue.slice(0, this.numberOfElements + 1);\n  }\n\n  public max(): T {\n    return this.priorityQueue[0];\n  }\n\n  private swim(k: number): void {\n    while (k > 0 && this.less(half(k), k)) {\n      this.exchange(k, half(k));\n      k = half(k);\n    }\n  }\n\n  private sink(k: number): void {\n    while (2 * k <= this.numberOfElements) {\n      let j = 2 * k;\n      if (j < this.numberOfElements && this.less(j, j + 1)) {\n        j++;\n      }\n      if (!this.less(k, j)) {\n        break;\n      }\n      this.exchange(k, j);\n      k = j;\n    }\n  }\n\n  private getValueAt(i: number): number {\n    return this.getElementValue(this.priorityQueue[i]);\n  }\n\n  private less(i: number, j: number): boolean {\n    return this.getValueAt(i) < this.getValueAt(j);\n  }\n\n  private exchange(i: number, j: number): void {\n    const t = this.priorityQueue[i];\n    this.priorityQueue[i] = this.priorityQueue[j];\n    this.priorityQueue[j] = t;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {PartWithScore, TensorBuffer3D} from '../types';\n\nimport {MaxHeap} from './max_heap';\n\nfunction scoreIsMaximumInLocalWindow(\n    keypointId: number, score: number, heatmapY: number, heatmapX: number,\n    localMaximumRadius: number, scores: TensorBuffer3D): boolean {\n  const [height, width] = scores.shape;\n\n  let localMaximum = true;\n  const yStart = Math.max(heatmapY - localMaximumRadius, 0);\n  const yEnd = Math.min(heatmapY + localMaximumRadius + 1, height);\n  for (let yCurrent = yStart; yCurrent < yEnd; ++yCurrent) {\n    const xStart = Math.max(heatmapX - localMaximumRadius, 0);\n    const xEnd = Math.min(heatmapX + localMaximumRadius + 1, width);\n    for (let xCurrent = xStart; xCurrent < xEnd; ++xCurrent) {\n      if (scores.get(yCurrent, xCurrent, keypointId) > score) {\n        localMaximum = false;\n        break;\n      }\n    }\n    if (!localMaximum) {\n      break;\n    }\n  }\n\n  return localMaximum;\n}\n\n/**\n * Builds a priority queue with part candidate positions for a specific image in\n * the batch. For this we find all local maxima in the score maps with score\n * values above a threshold. We create a single priority queue across all parts.\n */\nexport function buildPartWithScoreQueue(\n    scoreThreshold: number, localMaximumRadius: number,\n    scores: TensorBuffer3D): MaxHeap<PartWithScore> {\n  const [height, width, numKeypoints] = scores.shape;\n\n  const queue = new MaxHeap<PartWithScore>(\n      height * width * numKeypoints, ({score}) => score);\n\n  for (let heatmapY = 0; heatmapY < height; ++heatmapY) {\n    for (let heatmapX = 0; heatmapX < width; ++heatmapX) {\n      for (let keypointId = 0; keypointId < numKeypoints; ++keypointId) {\n        const score = scores.get(heatmapY, heatmapX, keypointId);\n\n        // Only consider parts with score greater or equal to threshold as\n        // root candidates.\n        if (score < scoreThreshold) {\n          continue;\n        }\n\n        // Only consider keypoints whose score is maximum in a local window.\n        if (scoreIsMaximumInLocalWindow(\n                keypointId, score, heatmapY, heatmapX, localMaximumRadius,\n                scores)) {\n          queue.enqueue({score, part: {heatmapY, heatmapX, id: keypointId}});\n        }\n      }\n    }\n  }\n\n  return queue;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport type Tuple<T> = [T, T];\nexport type StringTuple = Tuple<string>;\nexport type NumberTuple = Tuple<number>;\n\nexport const partNames = [\n  'nose', 'leftEye', 'rightEye', 'leftEar', 'rightEar', 'leftShoulder',\n  'rightShoulder', 'leftElbow', 'rightElbow', 'leftWrist', 'rightWrist',\n  'leftHip', 'rightHip', 'leftKnee', 'rightKnee', 'leftAnkle', 'rightAnkle'\n];\n\nexport const NUM_KEYPOINTS = partNames.length;\n\nexport interface NumberDict {\n  [jointName: string]: number;\n}\n\nexport const partIds =\n    partNames.reduce((result: NumberDict, jointName, i): NumberDict => {\n      result[jointName] = i;\n      return result;\n    }, {}) as NumberDict;\n\nconst connectedPartNames: StringTuple[] = [\n  ['leftHip', 'leftShoulder'], ['leftElbow', 'leftShoulder'],\n  ['leftElbow', 'leftWrist'], ['leftHip', 'leftKnee'],\n  ['leftKnee', 'leftAnkle'], ['rightHip', 'rightShoulder'],\n  ['rightElbow', 'rightShoulder'], ['rightElbow', 'rightWrist'],\n  ['rightHip', 'rightKnee'], ['rightKnee', 'rightAnkle'],\n  ['leftShoulder', 'rightShoulder'], ['leftHip', 'rightHip']\n];\n\n/*\n * Define the skeleton. This defines the parent->child relationships of our\n * tree. Arbitrarily this defines the nose as the root of the tree, however\n * since we will infer the displacement for both parent->child and\n * child->parent, we can define the tree root as any node.\n */\nexport const poseChain: StringTuple[] = [\n  ['nose', 'leftEye'], ['leftEye', 'leftEar'], ['nose', 'rightEye'],\n  ['rightEye', 'rightEar'], ['nose', 'leftShoulder'],\n  ['leftShoulder', 'leftElbow'], ['leftElbow', 'leftWrist'],\n  ['leftShoulder', 'leftHip'], ['leftHip', 'leftKnee'],\n  ['leftKnee', 'leftAnkle'], ['nose', 'rightShoulder'],\n  ['rightShoulder', 'rightElbow'], ['rightElbow', 'rightWrist'],\n  ['rightShoulder', 'rightHip'], ['rightHip', 'rightKnee'],\n  ['rightKnee', 'rightAnkle']\n];\n\nexport const connectedPartIndices = connectedPartNames.map(\n    ([jointNameA, jointNameB]) => ([partIds[jointNameA], partIds[jointNameB]]));\n\nexport const partChannels: string[] = [\n  'left_face',\n  'right_face',\n  'right_upper_leg_front',\n  'right_lower_leg_back',\n  'right_upper_leg_back',\n  'left_lower_leg_front',\n  'left_upper_leg_front',\n  'left_upper_leg_back',\n  'left_lower_leg_back',\n  'right_feet',\n  'right_lower_leg_front',\n  'left_feet',\n  'torso_front',\n  'torso_back',\n  'right_upper_arm_front',\n  'right_upper_arm_back',\n  'right_lower_arm_back',\n  'left_lower_arm_front',\n  'left_upper_arm_front',\n  'left_upper_arm_back',\n  'left_lower_arm_back',\n  'right_hand',\n  'right_lower_arm_front',\n  'left_hand'\n];\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NUM_KEYPOINTS} from '../keypoints';\nimport {Part, TensorBuffer3D, Vector2D} from '../types';\n\nexport function getOffsetPoint(\n    y: number, x: number, keypoint: number, offsets: TensorBuffer3D): Vector2D {\n  return {\n    y: offsets.get(y, x, keypoint),\n    x: offsets.get(y, x, keypoint + NUM_KEYPOINTS)\n  };\n}\n\nexport function getImageCoords(\n    part: Part, outputStride: number, offsets: TensorBuffer3D): Vector2D {\n  const {heatmapY, heatmapX, id: keypoint} = part;\n  const {y, x} = getOffsetPoint(heatmapY, heatmapX, keypoint, offsets);\n  return {\n    x: part.heatmapX * outputStride + x,\n    y: part.heatmapY * outputStride + y\n  };\n}\n\nexport function fillArray<T>(element: T, size: number): T[] {\n  const result: T[] = new Array(size);\n\n  for (let i = 0; i < size; i++) {\n    result[i] = element;\n  }\n\n  return result;\n}\n\nexport function clamp(a: number, min: number, max: number): number {\n  if (a < min) {\n    return min;\n  }\n  if (a > max) {\n    return max;\n  }\n  return a;\n}\n\nexport function squaredDistance(\n    y1: number, x1: number, y2: number, x2: number): number {\n  const dy = y2 - y1;\n  const dx = x2 - x1;\n  return dy * dy + dx * dx;\n}\n\nexport function addVectors(a: Vector2D, b: Vector2D): Vector2D {\n  return {x: a.x + b.x, y: a.y + b.y};\n}\n\nexport function clampVector(a: Vector2D, min: number, max: number): Vector2D {\n  return {y: clamp(a.y, min, max), x: clamp(a.x, min, max)};\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NumberTuple, partIds, partNames, poseChain} from '../keypoints';\nimport {Keypoint, PartWithScore, TensorBuffer3D, Vector2D} from '../types';\n\nimport {clamp, getOffsetPoint} from './util';\nimport {addVectors, getImageCoords} from './util';\n\nconst parentChildrenTuples: NumberTuple[] = poseChain.map(\n    ([parentJoinName, childJoinName]): NumberTuple =>\n        ([partIds[parentJoinName], partIds[childJoinName]]));\n\nconst parentToChildEdges: number[] =\n    parentChildrenTuples.map(([, childJointId]) => childJointId);\n\nconst childToParentEdges: number[] =\n    parentChildrenTuples.map(([\n                               parentJointId,\n                             ]) => parentJointId);\n\nfunction getDisplacement(\n    edgeId: number, point: Vector2D, displacements: TensorBuffer3D): Vector2D {\n  const numEdges = displacements.shape[2] / 2;\n  return {\n    y: displacements.get(point.y, point.x, edgeId),\n    x: displacements.get(point.y, point.x, numEdges + edgeId)\n  };\n}\n\nfunction getStridedIndexNearPoint(\n    point: Vector2D, outputStride: number, height: number,\n    width: number): Vector2D {\n  return {\n    y: clamp(Math.round(point.y / outputStride), 0, height - 1),\n    x: clamp(Math.round(point.x / outputStride), 0, width - 1)\n  };\n}\n\n/**\n * We get a new keypoint along the `edgeId` for the pose instance, assuming\n * that the position of the `idSource` part is already known. For this, we\n * follow the displacement vector from the source to target part (stored in\n * the `i`-t channel of the displacement tensor). The displaced keypoint\n * vector is refined using the offset vector by `offsetRefineStep` times.\n */\nfunction traverseToTargetKeypoint(\n    edgeId: number, sourceKeypoint: Keypoint, targetKeypointId: number,\n    scoresBuffer: TensorBuffer3D, offsets: TensorBuffer3D, outputStride: number,\n    displacements: TensorBuffer3D, offsetRefineStep = 2): Keypoint {\n  const [height, width] = scoresBuffer.shape;\n\n  // Nearest neighbor interpolation for the source->target displacements.\n  const sourceKeypointIndices = getStridedIndexNearPoint(\n      sourceKeypoint.position, outputStride, height, width);\n\n  const displacement =\n      getDisplacement(edgeId, sourceKeypointIndices, displacements);\n\n  const displacedPoint = addVectors(sourceKeypoint.position, displacement);\n  let targetKeypoint = displacedPoint;\n  for (let i = 0; i < offsetRefineStep; i++) {\n    const targetKeypointIndices =\n        getStridedIndexNearPoint(targetKeypoint, outputStride, height, width);\n\n    const offsetPoint = getOffsetPoint(\n        targetKeypointIndices.y, targetKeypointIndices.x, targetKeypointId,\n        offsets);\n\n    targetKeypoint = addVectors(\n        {\n          x: targetKeypointIndices.x * outputStride,\n          y: targetKeypointIndices.y * outputStride\n        },\n        {x: offsetPoint.x, y: offsetPoint.y});\n  }\n  const targetKeyPointIndices =\n      getStridedIndexNearPoint(targetKeypoint, outputStride, height, width);\n  const score = scoresBuffer.get(\n      targetKeyPointIndices.y, targetKeyPointIndices.x, targetKeypointId);\n\n  return {position: targetKeypoint, part: partNames[targetKeypointId], score};\n}\n\n/**\n * Follows the displacement fields to decode the full pose of the object\n * instance given the position of a part that acts as root.\n *\n * @return An array of decoded keypoints and their scores for a single pose\n */\nexport function decodePose(\n    root: PartWithScore, scores: TensorBuffer3D, offsets: TensorBuffer3D,\n    outputStride: number, displacementsFwd: TensorBuffer3D,\n    displacementsBwd: TensorBuffer3D): Keypoint[] {\n  const numParts = scores.shape[2];\n  const numEdges = parentToChildEdges.length;\n\n  const instanceKeypoints: Keypoint[] = new Array(numParts);\n  // Start a new detection instance at the position of the root.\n  const {part: rootPart, score: rootScore} = root;\n  const rootPoint = getImageCoords(rootPart, outputStride, offsets);\n\n  instanceKeypoints[rootPart.id] = {\n    score: rootScore,\n    part: partNames[rootPart.id],\n    position: rootPoint\n  };\n\n  // Decode the part positions upwards in the tree, following the backward\n  // displacements.\n  for (let edge = numEdges - 1; edge >= 0; --edge) {\n    const sourceKeypointId = parentToChildEdges[edge];\n    const targetKeypointId = childToParentEdges[edge];\n    if (instanceKeypoints[sourceKeypointId] &&\n        !instanceKeypoints[targetKeypointId]) {\n      instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(\n          edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores,\n          offsets, outputStride, displacementsBwd);\n    }\n  }\n\n  // Decode the part positions downwards in the tree, following the forward\n  // displacements.\n  for (let edge = 0; edge < numEdges; ++edge) {\n    const sourceKeypointId = childToParentEdges[edge];\n    const targetKeypointId = parentToChildEdges[edge];\n    if (instanceKeypoints[sourceKeypointId] &&\n        !instanceKeypoints[targetKeypointId]) {\n      instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(\n          edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores,\n          offsets, outputStride, displacementsFwd);\n    }\n  }\n\n  return instanceKeypoints;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Keypoint, Pose, TensorBuffer3D} from '../types';\n\nimport {buildPartWithScoreQueue} from './build_part_with_score_queue';\nimport {decodePose} from './decode_pose';\nimport {getImageCoords, squaredDistance} from './util';\n\nfunction withinNmsRadiusOfCorrespondingPoint(\n    poses: Pose[], squaredNmsRadius: number, {x, y}: {x: number, y: number},\n    keypointId: number): boolean {\n  return poses.some(({keypoints}) => {\n    const correspondingKeypoint = keypoints[keypointId].position;\n    return squaredDistance(\n               y, x, correspondingKeypoint.y, correspondingKeypoint.x) <=\n        squaredNmsRadius;\n  });\n}\n\n/* Score the newly proposed object instance without taking into account\n * the scores of the parts that overlap with any previously detected\n * instance.\n */\nfunction getInstanceScore(\n    existingPoses: Pose[], squaredNmsRadius: number,\n    instanceKeypoints: Keypoint[]): number {\n  let notOverlappedKeypointScores = instanceKeypoints.reduce(\n      (result, {position, score}, keypointId): number => {\n        if (!withinNmsRadiusOfCorrespondingPoint(\n                existingPoses, squaredNmsRadius, position, keypointId)) {\n          result += score;\n        }\n        return result;\n      }, 0.0);\n\n  return notOverlappedKeypointScores /= instanceKeypoints.length;\n}\n\n// A point (y, x) is considered as root part candidate if its score is a\n// maximum in a window |y - y'| <= kLocalMaximumRadius, |x - x'| <=\n// kLocalMaximumRadius.\nconst kLocalMaximumRadius = 1;\n\n/**\n * Detects multiple poses and finds their parts from part scores and\n * displacement vectors. It returns up to `maxDetections` object instance\n * detections in decreasing root score order. It works as follows: We first\n * create a priority queue with local part score maxima above\n * `scoreThreshold`, considering all parts at the same time. Then we\n * iteratively pull the top  element of the queue (in decreasing score order)\n * and treat it as a root candidate for a new object instance. To avoid\n * duplicate detections, we reject the root candidate if it is within a disk\n * of `nmsRadius` pixels from the corresponding part of a previously detected\n * instance, which is a form of part-based non-maximum suppression (NMS). If\n * the root candidate passes the NMS check, we start a new object instance\n * detection, treating the corresponding part as root and finding the\n * positions of the remaining parts by following the displacement vectors\n * along the tree-structured part graph. We assign to the newly detected\n * instance a score equal to the sum of scores of its parts which have not\n * been claimed by a previous instance (i.e., those at least `nmsRadius`\n * pixels away from the corresponding part of all previously detected\n * instances), divided by the total number of parts `numParts`.\n *\n * @param heatmapScores 3-D tensor with shape `[height, width, numParts]`.\n * The value of heatmapScores[y, x, k]` is the score of placing the `k`-th\n * object part at position `(y, x)`.\n *\n * @param offsets 3-D tensor with shape `[height, width, numParts * 2]`.\n * The value of [offsets[y, x, k], offsets[y, x, k + numParts]]` is the\n * short range offset vector of the `k`-th  object part at heatmap\n * position `(y, x)`.\n *\n * @param displacementsFwd 3-D tensor of shape\n * `[height, width, 2 * num_edges]`, where `num_edges = num_parts - 1` is the\n * number of edges (parent-child pairs) in the tree. It contains the forward\n * displacements between consecutive part from the root towards the leaves.\n *\n * @param displacementsBwd 3-D tensor of shape\n * `[height, width, 2 * num_edges]`, where `num_edges = num_parts - 1` is the\n * number of edges (parent-child pairs) in the tree. It contains the backward\n * displacements between consecutive part from the root towards the leaves.\n *\n * @param outputStride The output stride that was used when feed-forwarding\n * through the PoseNet model.  Must be 32, 16, or 8.\n *\n * @param maxPoseDetections Maximum number of returned instance detections per\n * image.\n *\n * @param scoreThreshold Only return instance detections that have root part\n * score greater or equal to this value. Defaults to 0.5.\n *\n * @param nmsRadius Non-maximum suppression part distance. It needs to be\n * strictly positive. Two parts suppress each other if they are less than\n * `nmsRadius` pixels away. Defaults to 20.\n *\n * @return An array of poses and their scores, each containing keypoints and\n * the corresponding keypoint scores.\n */\nexport function decodeMultiplePoses(\n    scoresBuffer: TensorBuffer3D, offsetsBuffer: TensorBuffer3D,\n    displacementsFwdBuffer: TensorBuffer3D,\n    displacementsBwdBuffer: TensorBuffer3D, outputStride: number,\n    maxPoseDetections: number, scoreThreshold = 0.5, nmsRadius = 20): Pose[] {\n  const poses: Pose[] = [];\n\n  const queue = buildPartWithScoreQueue(\n      scoreThreshold, kLocalMaximumRadius, scoresBuffer);\n\n  const squaredNmsRadius = nmsRadius * nmsRadius;\n\n  // Generate at most maxDetections object instances per image in\n  // decreasing root part score order.\n  while (poses.length < maxPoseDetections && !queue.empty()) {\n    // The top element in the queue is the next root candidate.\n    const root = queue.dequeue();\n\n    // Part-based non-maximum suppression: We reject a root candidate if it\n    // is within a disk of `nmsRadius` pixels from the corresponding part of\n    // a previously detected instance.\n    const rootImageCoords =\n        getImageCoords(root.part, outputStride, offsetsBuffer);\n    if (withinNmsRadiusOfCorrespondingPoint(\n            poses, squaredNmsRadius, rootImageCoords, root.part.id)) {\n      continue;\n    }\n\n    // Start a new detection instance at the position of the root.\n    const keypoints = decodePose(\n        root, scoresBuffer, offsetsBuffer, outputStride, displacementsFwdBuffer,\n        displacementsBwdBuffer);\n\n    const score = getInstanceScore(poses, squaredNmsRadius, keypoints);\n\n    poses.push({keypoints, score});\n  }\n\n  return poses;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\n\nfunction mod(a: tf.Tensor1D, b: number): tf.Tensor1D {\n  return tf.tidy(() => {\n    const floored = tf.div(a, tf.scalar(b, 'int32'));\n\n    return tf.sub(a, tf.mul(floored, tf.scalar(b, 'int32')));\n  });\n}\n\nexport function argmax2d(inputs: tf.Tensor3D): tf.Tensor2D {\n  const [height, width, depth] = inputs.shape;\n\n  return tf.tidy(() => {\n    const reshaped = tf.reshape(inputs, [height * width, depth]);\n    const coords = tf.argMax(reshaped, 0);\n\n    const yCoords = tf.expandDims(tf.div(coords, tf.scalar(width, 'int32')), 1);\n    const xCoords = tf.expandDims(mod(coords as tf.Tensor1D, width), 1);\n\n    return tf.concat([yCoords, xCoords], 1);\n  }) as tf.Tensor2D;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\nimport {NUM_KEYPOINTS} from '../keypoints';\nimport {Vector2D} from '../types';\n\nexport function getPointsConfidence(\n    heatmapScores: tf.TensorBuffer<tf.Rank.R3>,\n    heatMapCoords: tf.TensorBuffer<tf.Rank.R2>): Float32Array {\n  const numKeypoints = heatMapCoords.shape[0];\n  const result = new Float32Array(numKeypoints);\n\n  for (let keypoint = 0; keypoint < numKeypoints; keypoint++) {\n    const y = heatMapCoords.get(keypoint, 0);\n    const x = heatMapCoords.get(keypoint, 1);\n    result[keypoint] = heatmapScores.get(y, x, keypoint);\n  }\n\n  return result;\n}\n\nfunction getOffsetPoint(\n    y: number, x: number, keypoint: number,\n    offsetsBuffer: tf.TensorBuffer<tf.Rank.R3>): Vector2D {\n  return {\n    y: offsetsBuffer.get(y, x, keypoint),\n    x: offsetsBuffer.get(y, x, keypoint + NUM_KEYPOINTS)\n  };\n}\n\nexport function getOffsetVectors(\n    heatMapCoordsBuffer: tf.TensorBuffer<tf.Rank.R2>,\n    offsetsBuffer: tf.TensorBuffer<tf.Rank.R3>): tf.Tensor2D {\n  const result: number[] = [];\n\n  for (let keypoint = 0; keypoint < NUM_KEYPOINTS; keypoint++) {\n    const heatmapY = heatMapCoordsBuffer.get(keypoint, 0).valueOf();\n    const heatmapX = heatMapCoordsBuffer.get(keypoint, 1).valueOf();\n\n    const {x, y} = getOffsetPoint(heatmapY, heatmapX, keypoint, offsetsBuffer);\n\n    result.push(y);\n    result.push(x);\n  }\n\n  return tf.tensor2d(result, [NUM_KEYPOINTS, 2]);\n}\n\nexport function getOffsetPoints(\n    heatMapCoordsBuffer: tf.TensorBuffer<tf.Rank.R2>, outputStride: number,\n    offsetsBuffer: tf.TensorBuffer<tf.Rank.R3>): tf.Tensor2D {\n  return tf.tidy(() => {\n    const offsetVectors = getOffsetVectors(heatMapCoordsBuffer, offsetsBuffer);\n\n    return tf\n        .add(tf\n          .cast(tf\n            .mul(heatMapCoordsBuffer.toTensor(), tf.scalar(outputStride,\n              'int32')), 'float32'), offsetVectors);\n  });\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\n\nimport {partNames} from '../keypoints';\nimport {Keypoint, Pose, PoseNetOutputStride} from '../types';\n\nimport {argmax2d} from './argmax2d';\nimport {getOffsetPoints, getPointsConfidence} from './util';\n\n/**\n * Detects a single pose and finds its parts from part scores and offset\n * vectors. It returns a single pose detection. It works as follows:\n * argmax2d is done on the scores to get the y and x index in the heatmap\n * with the highest score for each part, which is essentially where the\n * part is most likely to exist. This produces a tensor of size 17x2, with\n * each row being the y and x index in the heatmap for each keypoint.\n * The offset vector for each for each part is retrieved by getting the\n * y and x from the offsets corresponding to the y and x index in the\n * heatmap for that part. This produces a tensor of size 17x2, with each\n * row being the offset vector for the corresponding keypoint.\n * To get the keypoint, each part’s heatmap y and x are multiplied\n * by the output stride then added to their corresponding offset vector,\n * which is in the same scale as the original image.\n *\n * @param heatmapScores 3-D tensor with shape `[height, width, numParts]`.\n * The value of heatmapScores[y, x, k]` is the score of placing the `k`-th\n * object part at position `(y, x)`.\n *\n * @param offsets 3-D tensor with shape `[height, width, numParts * 2]`.\n * The value of [offsets[y, x, k], offsets[y, x, k + numParts]]` is the\n * short range offset vector of the `k`-th  object part at heatmap\n * position `(y, x)`.\n *\n * @param outputStride The output stride that was used when feed-forwarding\n * through the PoseNet model.  Must be 32, 16, or 8.\n *\n * @return A promise that resolves with single pose with a confidence score,\n * which contains an array of keypoints indexed by part id, each with a score\n * and position.\n */\nexport async function decodeSinglePose(\n    heatmapScores: tf.Tensor3D, offsets: tf.Tensor3D,\n    outputStride: PoseNetOutputStride): Promise<Pose> {\n  let totalScore = 0.0;\n\n  const heatmapValues = argmax2d(heatmapScores);\n\n  const allTensorBuffers = await Promise.all(\n      [heatmapScores.buffer(), offsets.buffer(), heatmapValues.buffer()]);\n\n  const scoresBuffer = allTensorBuffers[0];\n  const offsetsBuffer = allTensorBuffers[1];\n  const heatmapValuesBuffer = allTensorBuffers[2];\n\n  const offsetPoints =\n      getOffsetPoints(heatmapValuesBuffer, outputStride, offsetsBuffer);\n  const offsetPointsBuffer = await offsetPoints.buffer();\n\n  const keypointConfidence =\n      Array.from(getPointsConfidence(scoresBuffer, heatmapValuesBuffer));\n\n  const keypoints = keypointConfidence.map((score, keypointId): Keypoint => {\n    totalScore += score;\n    return {\n      position: {\n        y: offsetPointsBuffer.get(keypointId, 0),\n        x: offsetPointsBuffer.get(keypointId, 1)\n      },\n      part: partNames[keypointId],\n      score\n    };\n  });\n\n  heatmapValues.dispose();\n  offsetPoints.dispose();\n\n  return {keypoints, score: totalScore / keypoints.length};\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nconst MOBILENET_BASE_URL =\n    'https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/';\nconst RESNET50_BASE_URL =\n    'https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/';\n\n// The PoseNet 2.0 ResNet50 models use the latest TensorFlow.js 1.0 model\n// format.\nexport function resNet50Checkpoint(stride: number, quantBytes: number): string {\n  const graphJson = `model-stride${stride}.json`;\n  // quantBytes=4 corresponding to the non-quantized full-precision checkpoints.\n  if (quantBytes === 4) {\n    return RESNET50_BASE_URL + `float/` + graphJson;\n  } else {\n    return RESNET50_BASE_URL + `quant${quantBytes}/` + graphJson;\n  }\n}\n\n// The PoseNet 2.0 MobileNetV1 models use the latest TensorFlow.js 1.0 model\n// format.\nexport function mobileNetCheckpoint(\n    stride: number, multiplier: number, quantBytes: number): string {\n  const toStr: {[key: number]: string} = {1.0: '100', 0.75: '075', 0.50: '050'};\n  const graphJson = `model-stride${stride}.json`;\n  // quantBytes=4 corresponding to the non-quantized full-precision checkpoints.\n  if (quantBytes === 4) {\n    return MOBILENET_BASE_URL + `float/${toStr[multiplier]}/` + graphJson;\n  } else {\n    return MOBILENET_BASE_URL + `quant${quantBytes}/${toStr[multiplier]}/` +\n        graphJson;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\n\nimport {BaseModel} from './base_model';\n\nconst imageNetMean = [-123.15, -115.90, -103.06];\n\nexport class ResNet extends BaseModel {\n  preprocessInput(input: tf.Tensor3D): tf.Tensor3D {\n    return tf.add(input, imageNetMean);\n  }\n\n  nameOutputResults(results: tf.Tensor3D[]) {\n    const [displacementFwd, displacementBwd, offsets, heatmap] = results;\n    return {offsets, heatmap, displacementFwd, displacementBwd};\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\n\nimport {connectedPartIndices} from './keypoints';\nimport {InputResolution, Keypoint, Padding, Pose, PosenetInput, PoseNetOutputStride, TensorBuffer3D, Vector2D} from './types';\n\nfunction eitherPointDoesntMeetConfidence(\n    a: number, b: number, minConfidence: number): boolean {\n  return (a < minConfidence || b < minConfidence);\n}\n\nexport function getAdjacentKeyPoints(\n    keypoints: Keypoint[], minConfidence: number): Keypoint[][] {\n  return connectedPartIndices.reduce(\n      (result: Keypoint[][], [leftJoint, rightJoint]): Keypoint[][] => {\n        if (eitherPointDoesntMeetConfidence(\n                keypoints[leftJoint].score, keypoints[rightJoint].score,\n                minConfidence)) {\n          return result;\n        }\n\n        result.push([keypoints[leftJoint], keypoints[rightJoint]]);\n\n        return result;\n      }, []);\n}\n\nconst {NEGATIVE_INFINITY, POSITIVE_INFINITY} = Number;\nexport function getBoundingBox(keypoints: Keypoint[]):\n    {maxX: number, maxY: number, minX: number, minY: number} {\n  return keypoints.reduce(({maxX, maxY, minX, minY}, {position: {x, y}}) => {\n    return {\n      maxX: Math.max(maxX, x),\n      maxY: Math.max(maxY, y),\n      minX: Math.min(minX, x),\n      minY: Math.min(minY, y)\n    };\n  }, {\n    maxX: NEGATIVE_INFINITY,\n    maxY: NEGATIVE_INFINITY,\n    minX: POSITIVE_INFINITY,\n    minY: POSITIVE_INFINITY\n  });\n}\n\nexport function getBoundingBoxPoints(keypoints: Keypoint[]): Vector2D[] {\n  const {minX, minY, maxX, maxY} = getBoundingBox(keypoints);\n  return [\n    {x: minX, y: minY}, {x: maxX, y: minY}, {x: maxX, y: maxY},\n    {x: minX, y: maxY}\n  ];\n}\n\nexport async function toTensorBuffers3D(tensors: tf.Tensor3D[]):\n    Promise<TensorBuffer3D[]> {\n  return Promise.all(tensors.map(tensor => tensor.buffer()));\n}\n\nexport function scalePose(\n    pose: Pose, scaleY: number, scaleX: number, offsetY = 0,\n    offsetX = 0): Pose {\n  return {\n    score: pose.score,\n    keypoints: pose.keypoints.map(({score, part, position}) => ({\n                                    score,\n                                    part,\n                                    position: {\n                                      x: position.x * scaleX + offsetX,\n                                      y: position.y * scaleY + offsetY\n                                    }\n                                  }))\n  };\n}\n\nexport function scalePoses(\n    poses: Pose[], scaleY: number, scaleX: number, offsetY = 0, offsetX = 0) {\n  if (scaleX === 1 && scaleY === 1 && offsetY === 0 && offsetX === 0) {\n    return poses;\n  }\n  return poses.map(pose => scalePose(pose, scaleY, scaleX, offsetY, offsetX));\n}\n\nexport function flipPoseHorizontal(pose: Pose, imageWidth: number): Pose {\n  return {\n    score: pose.score,\n    keypoints: pose.keypoints.map(\n        ({score, part, position}) => ({\n          score,\n          part,\n          position: {x: imageWidth - 1 - position.x, y: position.y}\n        }))\n  };\n}\n\nexport function flipPosesHorizontal(poses: Pose[], imageWidth: number) {\n  if (imageWidth <= 0) {\n    return poses;\n  }\n  return poses.map(pose => flipPoseHorizontal(pose, imageWidth));\n}\n\nexport function toValidInputResolution(\n    inputResolution: number, outputStride: PoseNetOutputStride): number {\n  if (isValidInputResolution(inputResolution, outputStride)) {\n    return inputResolution;\n  }\n\n  return Math.floor(inputResolution / outputStride) * outputStride + 1;\n}\n\nexport function validateInputResolution(inputResolution: InputResolution) {\n  tf.util.assert(\n      typeof inputResolution === 'number' ||\n          typeof inputResolution === 'object',\n      () => `Invalid inputResolution ${inputResolution}. ` +\n          `Should be a number or an object with width and height`);\n\n  if (typeof inputResolution === 'object') {\n    tf.util.assert(\n        typeof inputResolution.width === 'number',\n        () => `inputResolution.width has a value of ${\n            inputResolution.width} which is invalid; it must be a number`);\n    tf.util.assert(\n        typeof inputResolution.height === 'number',\n        () => `inputResolution.height has a value of ${\n            inputResolution.height} which is invalid; it must be a number`);\n  }\n}\n\nexport function getValidInputResolutionDimensions(\n    inputResolution: InputResolution,\n    outputStride: PoseNetOutputStride): [number, number] {\n  validateInputResolution(inputResolution);\n  if (typeof inputResolution === 'object') {\n    return [\n      toValidInputResolution(inputResolution.height, outputStride),\n      toValidInputResolution(inputResolution.width, outputStride),\n    ];\n  } else {\n    return [\n      toValidInputResolution(inputResolution, outputStride),\n      toValidInputResolution(inputResolution, outputStride),\n    ];\n  }\n}\n\nconst VALID_OUTPUT_STRIDES: PoseNetOutputStride[] = [8, 16, 32];\nexport function assertValidOutputStride(outputStride: PoseNetOutputStride) {\n  tf.util.assert(\n      typeof outputStride === 'number', () => 'outputStride is not a number');\n  tf.util.assert(\n      VALID_OUTPUT_STRIDES.indexOf(outputStride) >= 0,\n      () => `outputStride of ${outputStride} is invalid. ` +\n          `It must be either 8, 16, or 32`);\n}\n\nfunction isValidInputResolution(\n    resolution: number, outputStride: number): boolean {\n  return (resolution - 1) % outputStride === 0;\n}\n\nexport function assertValidResolution(\n    resolution: [number, number], outputStride: number) {\n  tf.util.assert(\n      typeof resolution[0] === 'number' && typeof resolution[1] === 'number',\n      () => `both resolution values must be a number but had values ${\n          resolution}`);\n\n  tf.util.assert(\n      isValidInputResolution(resolution[0], outputStride),\n      () => `height of ${resolution[0]} is invalid for output stride ` +\n          `${outputStride}.`);\n\n  tf.util.assert(\n      isValidInputResolution(resolution[1], outputStride),\n      () => `width of ${resolution[1]} is invalid for output stride ` +\n          `${outputStride}.`);\n}\n\nexport function getInputTensorDimensions(input: PosenetInput):\n    [number, number] {\n  return input instanceof tf.Tensor ? [input.shape[0], input.shape[1]] :\n                                      [input.height, input.width];\n}\n\nexport function toInputTensor(input: PosenetInput) {\n  return input instanceof tf.Tensor ? input : tf.browser.fromPixels(input);\n}\n\nexport function toResizedInputTensor(\n    input: PosenetInput, resizeHeight: number, resizeWidth: number,\n    flipHorizontal: boolean): tf.Tensor3D {\n  return tf.tidy(() => {\n    const imageTensor = toInputTensor(input);\n\n    if (flipHorizontal) {\n      return tf.image.resizeBilinear(tf.reverse(imageTensor, 1), [resizeHeight, resizeWidth]);\n    } else {\n      return tf.image.resizeBilinear(imageTensor, [resizeHeight, resizeWidth]);\n    }\n  });\n}\n\nexport function padAndResizeTo(\n    input: PosenetInput, [targetH, targetW]: [number, number]):\n    {resized: tf.Tensor3D, padding: Padding} {\n  const [height, width] = getInputTensorDimensions(input);\n  const targetAspect = targetW / targetH;\n  const aspect = width / height;\n  let [padT, padB, padL, padR] = [0, 0, 0, 0];\n  if (aspect < targetAspect) {\n    // pads the width\n    padT = 0;\n    padB = 0;\n    padL = Math.round(0.5 * (targetAspect * height - width));\n    padR = Math.round(0.5 * (targetAspect * height - width));\n  } else {\n    // pads the height\n    padT = Math.round(0.5 * ((1.0 / targetAspect) * width - height));\n    padB = Math.round(0.5 * ((1.0 / targetAspect) * width - height));\n    padL = 0;\n    padR = 0;\n  }\n\n  const resized: tf.Tensor3D = tf.tidy(() => {\n    let imageTensor = toInputTensor(input);\n    imageTensor = tf.pad3d(imageTensor, [[padT, padB], [padL, padR], [0, 0]]);\n\n    return tf.image.resizeBilinear(imageTensor, [targetH, targetW]);\n  });\n\n  return {resized, padding: {top: padT, left: padL, right: padR, bottom: padB}};\n}\n\nexport function scaleAndFlipPoses(\n    poses: Pose[], [height, width]: [number, number],\n    [inputResolutionHeight, inputResolutionWidth]: [number, number],\n    padding: Padding, flipHorizontal: boolean): Pose[] {\n  const scaleY =\n      (height + padding.top + padding.bottom) / (inputResolutionHeight);\n  const scaleX =\n      (width + padding.left + padding.right) / (inputResolutionWidth);\n\n  const scaledPoses =\n      scalePoses(poses, scaleY, scaleX, -padding.top, -padding.left);\n\n  if (flipHorizontal) {\n    return flipPosesHorizontal(scaledPoses, width);\n  } else {\n    return scaledPoses;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tfconv from '@tensorflow/tfjs-converter';\nimport * as tf from '@tensorflow/tfjs-core';\n\nimport {BaseModel} from './base_model';\nimport {mobileNetCheckpoint, resNet50Checkpoint} from './checkpoints';\nimport {MobileNet} from './mobilenet';\nimport {decodeMultiplePoses} from './multi_pose/decode_multiple_poses';\nimport {ResNet} from './resnet';\nimport {decodeSinglePose} from './single_pose/decode_single_pose';\nimport {InputResolution, MobileNetMultiplier, Pose, PoseNetArchitecture, PosenetInput, PoseNetOutputStride, PoseNetQuantBytes} from './types';\nimport {assertValidOutputStride, assertValidResolution, getInputTensorDimensions, getValidInputResolutionDimensions, padAndResizeTo, scaleAndFlipPoses, toTensorBuffers3D, validateInputResolution} from './util';\n\n/**\n * PoseNet model loading is configurable using the following config dictionary.\n *\n * `architecture`: PoseNetArchitecture. It determines wich PoseNet architecture\n * to load. The supported architectures are: MobileNetV1 and ResNet.\n *\n * `outputStride`: Specifies the output stride of the PoseNet model.\n * The smaller the value, the larger the output resolution, and more accurate\n * the model at the cost of speed.  Set this to a larger value to increase speed\n * at the cost of accuracy. Stride 32 is supported for ResNet and\n * stride 8,16,32 are supported for various MobileNetV1 models.\n *\n * * `inputResolution`: A number or an Object of type {width: number, height:\n * number}. Specifies the size the input image is scaled to before feeding it\n * through the PoseNet model.  The larger the value, more accurate the model at\n * the cost of speed. Set this to a smaller value to increase speed at the cost\n * of accuracy. If a number is provided, the input will be resized and padded to\n * be a square with the same width and height.  If width and height are\n * provided, the input will be resized and padded to the specified width and\n * height.\n *\n * `multiplier`: An optional number with values: 1.01, 1.0, 0.75, or\n * 0.50. The value is used only by MobileNet architecture. It is the float\n * multiplier for the depth (number of channels) for all convolution ops.\n * The larger the value, the larger the size of the layers, and more accurate\n * the model at the cost of speed. Set this to a smaller value to increase speed\n * at the cost of accuracy.\n *\n * `modelUrl`: An optional string that specifies custom url of the model. This\n * is useful for area/countries that don't have access to the model hosted on\n * GCP.\n *\n * `quantBytes`: An opional number with values: 1, 2, or 4.  This parameter\n * affects weight quantization in the models. The available options are\n * 1 byte, 2 bytes, and 4 bytes. The higher the value, the larger the model size\n * and thus the longer the loading time, the lower the value, the shorter the\n * loading time but lower the accuracy.\n */\nexport interface ModelConfig {\n  architecture: PoseNetArchitecture;\n  outputStride: PoseNetOutputStride;\n  inputResolution: InputResolution;\n  multiplier?: MobileNetMultiplier;\n  modelUrl?: string;\n  quantBytes?: PoseNetQuantBytes;\n}\n\n// The default configuration for loading MobileNetV1 based PoseNet.\n//\n// (And for references, the default configuration for loading ResNet\n// based PoseNet is also included).\n//\n// ```\n// const RESNET_CONFIG = {\n//   architecture: 'ResNet50',\n//   outputStride: 32,\n//   quantBytes: 2,\n// } as ModelConfig;\n// ```\nconst MOBILENET_V1_CONFIG: ModelConfig = {\n  architecture: 'MobileNetV1',\n  outputStride: 16,\n  multiplier: 0.75,\n  inputResolution: 257,\n} as ModelConfig;\n\nconst VALID_ARCHITECTURE = ['MobileNetV1', 'ResNet50'];\nconst VALID_STRIDE = {\n  'MobileNetV1': [8, 16, 32],\n  'ResNet50': [32, 16]\n};\n\nconst VALID_MULTIPLIER = {\n  'MobileNetV1': [0.50, 0.75, 1.0],\n  'ResNet50': [1.0]\n};\nconst VALID_QUANT_BYTES = [1, 2, 4];\n\nfunction validateModelConfig(config: ModelConfig) {\n  config = config || MOBILENET_V1_CONFIG;\n\n  if (config.architecture == null) {\n    config.architecture = 'MobileNetV1';\n  }\n  if (VALID_ARCHITECTURE.indexOf(config.architecture) < 0) {\n    throw new Error(\n        `Invalid architecture ${config.architecture}. ` +\n        `Should be one of ${VALID_ARCHITECTURE}`);\n  }\n\n  if (config.inputResolution == null) {\n    config.inputResolution = 257;\n  }\n\n  validateInputResolution(config.inputResolution);\n\n  if (config.outputStride == null) {\n    config.outputStride = 16;\n  }\n  if (VALID_STRIDE[config.architecture].indexOf(config.outputStride) < 0) {\n    throw new Error(\n        `Invalid outputStride ${config.outputStride}. ` +\n        `Should be one of ${VALID_STRIDE[config.architecture]} ` +\n        `for architecture ${config.architecture}.`);\n  }\n\n  if (config.multiplier == null) {\n    config.multiplier = 1.0;\n  }\n  if (VALID_MULTIPLIER[config.architecture].indexOf(config.multiplier) < 0) {\n    throw new Error(\n        `Invalid multiplier ${config.multiplier}. ` +\n        `Should be one of ${VALID_MULTIPLIER[config.architecture]} ` +\n        `for architecture ${config.architecture}.`);\n  }\n\n  if (config.quantBytes == null) {\n    config.quantBytes = 4;\n  }\n  if (VALID_QUANT_BYTES.indexOf(config.quantBytes) < 0) {\n    throw new Error(\n        `Invalid quantBytes ${config.quantBytes}. ` +\n        `Should be one of ${VALID_QUANT_BYTES} ` +\n        `for architecture ${config.architecture}.`);\n  }\n\n  if (config.architecture === 'MobileNetV1' && config.outputStride === 32 &&\n      config.multiplier !== 1) {\n    throw new Error(\n        `When using an output stride of 32, ` +\n        `you must select 1 as the multiplier.`);\n  }\n\n  return config;\n}\n\n/**\n * PoseNet inference is configurable using the following config dictionary.\n *\n * `flipHorizontal`: If the poses should be flipped/mirrored horizontally.\n * This should be set to true for videos where the video is by default flipped\n * horizontally (i.e. a webcam), and you want the poses to be returned in the\n * proper orientation.\n *\n */\nexport interface InferenceConfig {\n  flipHorizontal: boolean;\n}\n\n/**\n * Single Person Inference Config\n */\nexport interface SinglePersonInterfaceConfig extends InferenceConfig {}\n\n/**\n * Multiple Person Inference Config\n *\n * `maxDetections`: Maximum number of returned instance detections per image.\n *\n * `scoreThreshold`: Only return instance detections that have root part\n * score greater or equal to this value. Defaults to 0.5\n *\n * `nmsRadius`: Non-maximum suppression part distance in pixels. It needs\n * to be strictly positive. Two parts suppress each other if they are less\n * than `nmsRadius` pixels away. Defaults to 20.\n */\nexport interface MultiPersonInferenceConfig extends InferenceConfig {\n  maxDetections?: number;\n  scoreThreshold?: number;\n  nmsRadius?: number;\n}\n\n// these added back to not break the existing api.\nexport interface LegacyMultiPersonInferenceConfig extends\n    MultiPersonInferenceConfig {\n  decodingMethod: 'multi-person';\n}\n\nexport interface LegacySinglePersonInferenceConfig extends\n    SinglePersonInterfaceConfig {\n  decodingMethod: 'single-person';\n}\n\nexport const SINGLE_PERSON_INFERENCE_CONFIG: SinglePersonInterfaceConfig = {\n  flipHorizontal: false\n};\n\nexport const MULTI_PERSON_INFERENCE_CONFIG: MultiPersonInferenceConfig = {\n  flipHorizontal: false,\n  maxDetections: 5,\n  scoreThreshold: 0.5,\n  nmsRadius: 20\n};\n\nfunction validateSinglePersonInferenceConfig(\n    config: SinglePersonInterfaceConfig) {}\n\nfunction validateMultiPersonInputConfig(config: MultiPersonInferenceConfig) {\n  const {maxDetections, scoreThreshold, nmsRadius} = config;\n\n  if (maxDetections <= 0) {\n    throw new Error(\n        `Invalid maxDetections ${maxDetections}. ` +\n        `Should be > 0`);\n  }\n\n  if (scoreThreshold < 0.0 || scoreThreshold > 1.0) {\n    throw new Error(\n        `Invalid scoreThreshold ${scoreThreshold}. ` +\n        `Should be in range [0.0, 1.0]`);\n  }\n\n  if (nmsRadius <= 0) {\n    throw new Error(`Invalid nmsRadius ${nmsRadius}.`);\n  }\n}\n\nexport class PoseNet {\n  readonly baseModel: BaseModel;\n  readonly inputResolution: [number, number];\n\n  constructor(net: BaseModel, inputResolution: [number, number]) {\n    assertValidOutputStride(net.outputStride);\n    assertValidResolution(inputResolution, net.outputStride);\n\n    this.baseModel = net;\n    this.inputResolution = inputResolution;\n  }\n\n  /**\n   * Infer through PoseNet, and estimates multiple poses using the outputs.\n   * This does standard ImageNet pre-processing before inferring through the\n   * model. The image should pixels should have values [0-255]. It detects\n   * multiple poses and finds their parts from part scores and displacement\n   * vectors using a fast greedy decoding algorithm.  It returns up to\n   * `config.maxDetections` object instance detections in decreasing root\n   * score order.\n   *\n   * @param input\n   * ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement) The input\n   * image to feed through the network.\n   *\n   * @param config MultiPoseEstimationConfig object that contains parameters\n   * for the PoseNet inference using multiple pose estimation.\n   *\n   * @return An array of poses and their scores, each containing keypoints and\n   * the corresponding keypoint scores.  The positions of the keypoints are\n   * in the same scale as the original image\n   */\n  async estimateMultiplePoses(\n      input: PosenetInput,\n      config: MultiPersonInferenceConfig = MULTI_PERSON_INFERENCE_CONFIG):\n      Promise<Pose[]> {\n    const configWithDefaults: MultiPersonInferenceConfig = {\n      ...MULTI_PERSON_INFERENCE_CONFIG,\n      ...config\n    };\n\n    validateMultiPersonInputConfig(config);\n\n    const outputStride = this.baseModel.outputStride;\n    const inputResolution = this.inputResolution;\n\n    const [height, width] = getInputTensorDimensions(input);\n\n    const {resized, padding} = padAndResizeTo(input, inputResolution);\n\n    const {heatmapScores, offsets, displacementFwd, displacementBwd} =\n        this.baseModel.predict(resized);\n\n    const allTensorBuffers = await toTensorBuffers3D(\n        [heatmapScores, offsets, displacementFwd, displacementBwd]);\n\n    const scoresBuffer = allTensorBuffers[0];\n    const offsetsBuffer = allTensorBuffers[1];\n    const displacementsFwdBuffer = allTensorBuffers[2];\n    const displacementsBwdBuffer = allTensorBuffers[3];\n\n    const poses = await decodeMultiplePoses(\n        scoresBuffer, offsetsBuffer, displacementsFwdBuffer,\n        displacementsBwdBuffer, outputStride, configWithDefaults.maxDetections,\n        configWithDefaults.scoreThreshold, configWithDefaults.nmsRadius);\n\n    const resultPoses = scaleAndFlipPoses(\n        poses, [height, width], inputResolution, padding,\n        configWithDefaults.flipHorizontal);\n\n    heatmapScores.dispose();\n    offsets.dispose();\n    displacementFwd.dispose();\n    displacementBwd.dispose();\n    resized.dispose();\n\n    return resultPoses;\n  }\n\n  /**\n   * Infer through PoseNet, and estimates a single pose using the outputs.\n   * This does standard ImageNet pre-processing before inferring through the\n   * model. The image should pixels should have values [0-255]. It detects\n   * multiple poses and finds their parts from part scores and displacement\n   * vectors using a fast greedy decoding algorithm.  It returns a single pose\n   *\n   * @param input\n   * ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement) The input\n   * image to feed through the network.\n   *\n   * @param config SinglePersonEstimationConfig object that contains\n   * parameters for the PoseNet inference using single pose estimation.\n   *\n   * @return An pose and its scores, containing keypoints and\n   * the corresponding keypoint scores.  The positions of the keypoints are\n   * in the same scale as the original image\n   */\n  async estimateSinglePose(\n      input: PosenetInput,\n      config: SinglePersonInterfaceConfig = SINGLE_PERSON_INFERENCE_CONFIG):\n      Promise<Pose> {\n    const configWithDefaults = {...SINGLE_PERSON_INFERENCE_CONFIG, ...config};\n\n    validateSinglePersonInferenceConfig(configWithDefaults);\n\n    const outputStride = this.baseModel.outputStride;\n    const inputResolution = this.inputResolution;\n\n    const [height, width] = getInputTensorDimensions(input);\n\n    const {resized, padding} = padAndResizeTo(input, inputResolution);\n\n    const {heatmapScores, offsets, displacementFwd, displacementBwd} =\n        this.baseModel.predict(resized);\n\n    const pose = await decodeSinglePose(heatmapScores, offsets, outputStride);\n    const poses = [pose];\n\n    const resultPoses = scaleAndFlipPoses(\n        poses, [height, width], inputResolution, padding,\n        configWithDefaults.flipHorizontal);\n\n    heatmapScores.dispose();\n    offsets.dispose();\n    displacementFwd.dispose();\n    displacementBwd.dispose();\n    resized.dispose();\n\n    return resultPoses[0];\n  }\n\n  /** Deprecated: Use either estimateSinglePose or estimateMultiplePoses */\n  async estimatePoses(\n      input: PosenetInput,\n      config: LegacySinglePersonInferenceConfig|\n      LegacyMultiPersonInferenceConfig): Promise<Pose[]> {\n    if (config.decodingMethod === 'single-person') {\n      const pose = await this.estimateSinglePose(input, config);\n      return [pose];\n    } else {\n      return this.estimateMultiplePoses(input, config);\n    }\n  }\n\n  public dispose() {\n    this.baseModel.dispose();\n  }\n}\n\nasync function loadMobileNet(config: ModelConfig): Promise<PoseNet> {\n  const outputStride = config.outputStride;\n  const quantBytes = config.quantBytes;\n  const multiplier = config.multiplier;\n  if (tf == null) {\n    throw new Error(\n        `Cannot find TensorFlow.js. If you are using a <script> tag, please ` +\n        `also include @tensorflow/tfjs on the page before using this\n        model.`);\n  }\n\n  const url = mobileNetCheckpoint(outputStride, multiplier, quantBytes);\n  const graphModel = await tfconv.loadGraphModel(config.modelUrl || url);\n  const mobilenet = new MobileNet(graphModel, outputStride);\n\n  const validInputResolution = getValidInputResolutionDimensions(\n      config.inputResolution, mobilenet.outputStride);\n\n  return new PoseNet(mobilenet, validInputResolution);\n}\n\nasync function loadResNet(config: ModelConfig): Promise<PoseNet> {\n  const outputStride = config.outputStride;\n  const quantBytes = config.quantBytes;\n  if (tf == null) {\n    throw new Error(\n        `Cannot find TensorFlow.js. If you are using a <script> tag, please ` +\n        `also include @tensorflow/tfjs on the page before using this\n        model.`);\n  }\n\n  const url = resNet50Checkpoint(outputStride, quantBytes);\n  const graphModel = await tfconv.loadGraphModel(config.modelUrl || url);\n  const resnet = new ResNet(graphModel, outputStride);\n  const validInputResolution = getValidInputResolutionDimensions(\n      config.inputResolution, resnet.outputStride);\n  return new PoseNet(resnet, validInputResolution);\n}\n\n/**\n * Loads the PoseNet model instance from a checkpoint, with the ResNet\n * or MobileNet architecture. The model to be loaded is configurable using the\n * config dictionary ModelConfig. Please find more details in the\n * documentation of the ModelConfig.\n *\n * @param config ModelConfig dictionary that contains parameters for\n * the PoseNet loading process. Please find more details of each parameters\n * in the documentation of the ModelConfig interface. The predefined\n * `MOBILENET_V1_CONFIG` and `RESNET_CONFIG` can also be used as references\n * for defining your customized config.\n */\nexport async function load(config: ModelConfig = MOBILENET_V1_CONFIG):\n    Promise<PoseNet> {\n  config = validateModelConfig(config);\n  if (config.architecture === 'ResNet50') {\n    return loadResNet(config);\n  } else if (config.architecture === 'MobileNetV1') {\n    return loadMobileNet(config);\n  } else {\n    return null;\n  }\n}\n","/** @license See the LICENSE file. */\n\n// This code is auto-generated, do not modify this file!\nconst version = '2.2.2';\nexport {version};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}